"""The `prompts` module for prompting LLMs with data pulled from the database."""

import inspect
from collections.abc import Callable, Coroutine
from functools import wraps
from typing import Any, ParamSpec, Protocol, TypeVar, overload

from ._utils import (
    create_mirascope_call,
    create_mirascope_middleware,
    inspect_arguments,
    load_config,
)
from .server.client import LilypadClient
from .server.settings import get_settings

_P = ParamSpec("_P")
_R = TypeVar("_R")

config = load_config()
settings = get_settings()

lilypad_client = LilypadClient(
    base_url=settings.api_url,
    timeout=10,
    token=config.get("token", None),
)


class PromptDecorator(Protocol):
    """Protocol for the `prompt` decorator return type."""

    @overload
    def __call__(
        self, fn: Callable[_P, Coroutine[Any, Any, _R]]
    ) -> Callable[_P, Coroutine[Any, Any, _R]]: ...

    @overload
    def __call__(self, fn: Callable[_P, _R]) -> Callable[_P, _R]: ...

    def __call__(
        self, fn: Callable[_P, _R] | Callable[_P, Coroutine[Any, Any, _R]]
    ) -> Callable[_P, _R] | Callable[_P, Coroutine[Any, Any, _R]]:
        """Protocol `call` definition for `prompt` decorator return type."""
        ...


def prompt() -> PromptDecorator:
    """The `prompt` decorator for turning a Python function into an LLM prompt.

    The decorated function will not be run and will be used only for it's signature. The
    function will be called with the data pulled from the database, and the return value
    will be generated by the LLM.

    Functions decorated with `prompt` will be versioned and traced automatically.

    Returns:
        PromptDecorator: The `prompt` decorator.
    """

    @overload
    def decorator(
        fn: Callable[_P, Coroutine[Any, Any, _R]],
    ) -> Callable[_P, Coroutine[Any, Any, _R]]: ...

    @overload
    def decorator(fn: Callable[_P, _R]) -> Callable[_P, _R]: ...

    def decorator(
        fn: Callable[_P, _R] | Callable[_P, Coroutine[Any, Any, _R]],
    ) -> Callable[_P, _R] | Callable[_P, Coroutine[Any, Any, _R]]:
        prompt_template = (
            fn._prompt_template if hasattr(fn, "_prompt_template") else ""  # pyright: ignore[reportFunctionMemberAccess]
        )
        if inspect.iscoroutinefunction(fn):

            @wraps(fn)
            async def inner_async(*args: _P.args, **kwargs: _P.kwargs) -> _R:
                arg_types, arg_values = inspect_arguments(fn, *args, **kwargs)
                version = lilypad_client.get_prompt_active_version(fn)
                decorator = create_mirascope_middleware(
                    version, arg_types, arg_values, True, prompt_template
                )
                call = create_mirascope_call(fn, version.prompt, decorator)
                return await call(*args, **kwargs)

            return inner_async
        else:

            @wraps(fn)
            def inner(*args: _P.args, **kwargs: _P.kwargs) -> _R:
                arg_types, arg_values = inspect_arguments(fn, *args, **kwargs)
                version = lilypad_client.get_prompt_active_version(fn)
                decorator = create_mirascope_middleware(
                    version, arg_types, arg_values, False, prompt_template
                )
                call = create_mirascope_call(fn, version.prompt, decorator)
                return call(*args, **kwargs)  # pyright: ignore [reportReturnType]

            return inner

    return decorator


__all__ = ["prompt"]
